<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simulador de Pedalboard</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Font Awesome for share icon -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            overflow: hidden; /* Prevent body scroll, canvas handles pan */
        }
        #pedalboardCanvas {
            background-color: #2d3748; /* Default canvas background color, now fixed */
            border: 2px solid #4a5568;
            cursor: grab;
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
            display: block; /* Ensures no extra space below canvas */
            /* Canvas dimensions will be set by JS to fill available space */
        }
        #pedalboardCanvas.dragging {
            cursor: grabbing;
        }
        /* Common input field styles */
        .input-field {
            padding: 0.5rem; /* p-2 */
            border-radius: 0.375rem; /* rounded-md */
            background-color: #4a5568; /* bg-gray-700 */
            border: 1px solid #4a5568; /* border border-gray-600 */
            outline: none; /* focus:outline-none */
            color: white; /* text-white */
        }
        .input-field:focus {
            box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.5); /* focus:ring-2 focus:ring-blue-500 */
            border-color: #4299e1; /* focus:ring-blue-500 */
        }
        /* Common button styles */
        .btn {
            padding: 0.5rem 1rem; /* px-4 py-2 */
            border-radius: 0.375rem; /* rounded-md */
            font-weight: 600; /* font-semibold */
            outline: none; /* focus:outline-none */
            box-shadow: 0 0 0 2px transparent, 0 0 0 4px transparent; /* focus:ring-2 focus:ring-offset-2 */
            transition: background-color 0.2s ease-in-out;
        }
        .btn:focus {
            box-shadow: 0 0 0 2px white, 0 0 0 4px rgba(100, 116, 139, 0.5); /* focus:ring-offset-2 and default ring color */
        }
        /* Primary button */
        .btn-primary {
            background-color: #3182ce; /* bg-blue-600 */
            color: white; /* text-white */
        }
        .btn-primary:hover {
            background-color: #2b6cb0; /* hover:bg-blue-700 */
        }
        .btn-primary:focus {
            box-shadow: 0 0 0 2px white, 0 0 0 4px rgba(66, 153, 225, 0.5); /* focus:ring-blue-500 */
        }
        /* Danger button */
        .btn-danger {
            background-color: #e53e3e; /* bg-red-600 */
            color: white; /* text-white */
        }
        .btn-danger:hover {
            background-color: #c53030; /* hover:bg-red-700 */
        }
        .btn-danger:focus {
            box-shadow: 0 0 0 2px white, 0 0 0 4px rgba(239, 68, 68, 0.5); /* focus:ring-red-500 */
        }
        /* Secondary button */
        .btn-secondary {
            background-color: #4a5568; /* bg-gray-600 */
            color: white; /* text-white */
        }
        .btn-secondary:hover {
            background-color: #2d3748; /* hover:bg-gray-700 */
        }
        .btn-secondary:focus {
            box-shadow: 0 0 0 2px white, 0 0 0 4px rgba(160, 174, 192, 0.5); /* focus:ring-gray-500 */
        }
        /* Style for the share URL modal */
        .share-modal {
            position: fixed;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            background-color: rgba(26, 32, 44, 0.75); /* bg-gray-900 bg-opacity-75 */
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 50;
            padding: 1rem; /* p-4 */
        }
        .share-modal.hidden {
            display: none;
        }
        .share-modal-content {
            background-color: #2d3748; /* bg-gray-800 */
            padding: 1.5rem; /* p-6 */
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04); /* shadow-xl */
            max-width: 24rem; /* max-w-sm */
            width: 100%; /* w-full */
            text-align: center; /* text-center */
        }
        .share-modal-content input {
            margin-bottom: 1rem; /* mb-4 */
        }
        .share-modal-content button {
            width: 100%; /* w-full */
        }
        /* Fixed Share Button */
        #shareBoardBtn {
            position: fixed;
            bottom: 1rem; /* 16px */
            right: 1rem; /* 16px */
            background-color: #8b5cf6; /* Purple */
            color: white;
            padding: 1rem; /* 16px */
            border-radius: 9999px; /* Full rounded */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* lg shadow */
            z-index: 40;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s ease-in-out, transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            width: 60px; /* Make it a fixed size circle */
            height: 60px;
        }
        #shareBoardBtn:hover {
            background-color: #7c3aed; /* Darker purple on hover */
        }
        #shareBoardBtn:focus {
            outline: none;
            box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.4); /* Purple ring on focus */
        }
        #shareBoardBtn i {
            font-size: 1.5rem; /* Icon size */
        }

        /* Custom alert message area for scroll */
        #custom-alert-message {
            max-height: 15rem; /* Limit height */
            overflow-y: auto; /* Add scroll if content overflows */
            text-align: left; /* Align text left for readability */
            white-space: pre-wrap; /* Preserve whitespace and wrap text */
        }
        /* Custom select styling */
        .custom-select {
            display: block;
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.375rem;
            background-color: #4a5568;
            border: 1px solid #4a5568;
            color: white;
            appearance: none; /* Remove default browser styling */
            -webkit-appearance: none;
            -moz-appearance: none;
            background-image: url('data:image/svg+xml;utf8,<svg fill="%23e2e8f0" height="24" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><path d="M7 10l5 5 5-5z"/><path d="M0 0h24v24H0z" fill="none"/></svg>');
            background-repeat: no-repeat;
            background-position: right 0.5rem center;
            background-size: 1.5em;
            cursor: pointer;
        }
        .custom-select:focus {
            box-shadow: 0 0 0 2px rgba(66, 153, 225, 0.5);
            border-color: #4299e1;
            outline: none;
        }
    </style>
</head>
<body class="flex flex-col min-h-screen relative">
    <header class="bg-gray-800 p-4 shadow-md z-10">
        <h1 class="text-3xl font-bold text-center text-blue-400">Simulador de Pedalboard</h1>
    </header>

    <main class="flex flex-1 relative">
        <!-- Painel de Controle (Sidebar) -->
        <aside id="sidebar" class="fixed top-0 left-0 h-full w-full lg:w-1/4 bg-gray-800 p-6 shadow-lg z-50 overflow-y-auto transform -translate-x-full transition-transform duration-300 ease-in-out">
            <button id="closeSidebarBtn" class="absolute top-4 right-4 text-gray-300 hover:text-white text-2xl">&times;</button>

            <h2 class="text-2xl font-semibold mb-6 text-blue-300">Adicionar Pedalboard</h2>
            <div class="space-y-4">
                <div>
                    <label for="boardName" class="block text-sm font-medium text-gray-300 mb-1">Nome do Board:</label>
                    <input type="text" id="boardName" class="input-field w-full" placeholder="Ex: Meu Board Principal">
                </div>
                <div class="flex gap-4">
                    <div class="flex-1">
                        <label for="boardWidth" class="block text-sm font-medium text-gray-300 mb-1">Largura (cm):</label>
                        <input type="number" id="boardWidth" class="input-field w-full" value="60" min="1">
                    </div>
                    <div class="flex-1">
                        <label for="boardHeight" class="block text-sm font-medium text-gray-300 mb-1">Altura (cm):</label>
                        <input type="number" id="boardHeight" class="input-field w-full" value="30" min="1">
                    </div>
                </div>
                <button id="addBoardBtn" class="btn btn-secondary w-full mt-4">Adicionar Pedalboard</button>
            </div>

            <hr class="my-8 border-gray-700">

            <h2 class="text-2xl font-semibold mb-6 text-blue-300">Adicionar Pedal</h2>

            <div class="space-y-4">
                <div>
                    <label for="pedalName" class="block text-sm font-medium text-gray-300 mb-1">Nome do Pedal:</label>
                    <input type="text" id="pedalName" class="input-field w-full" placeholder="Ex: Overdrive">
                </div>
                <div class="flex gap-4">
                    <div class="flex-1">
                        <label for="pedalWidth" class="block text-sm font-medium text-gray-300 mb-1">Largura (cm):</label>
                        <input type="number" id="pedalWidth" class="input-field w-full" value="7" min="1">
                    </div>
                    <div class="flex-1">
                        <label for="pedalHeight" class="block text-sm font-medium text-gray-300 mb-1">Altura (cm):</label>
                        <input type="number" id="pedalHeight" class="input-field w-full" value="12" min="1">
                    </div>
                </div>
                <div>
                    <label for="pedalColor" class="block text-sm font-medium text-gray-300 mb-1">Cor do Pedal:</label>
                    <input type="color" id="pedalColor" class="w-full h-10 rounded-md cursor-pointer" value="#3498db">
                </div>
                <button id="addPedalBtn" class="btn btn-primary w-full mt-4">Adicionar Pedal</button>
            </div>

            <hr class="my-8 border-gray-700">

            <!-- Novo: Pedalboards Pré-definidos -->
            <h2 class="text-2xl font-semibold mb-6 text-blue-300">Pedalboard Pré-definido</h2>
            <div class="space-y-4">
                <div>
                    <label for="predefinedBoardSelect" class="block text-sm font-medium text-gray-300 mb-1">Selecione:</label>
                    <select id="predefinedBoardSelect" class="custom-select w-full">
                        <option value="">-- Selecione um Pedalboard --</option>
                    </select>
                </div>
            </div>

            <hr class="my-8 border-gray-700">

            <!-- Novo: Pedais Pré-definidos -->
            <h2 class="text-2xl font-semibold mb-6 text-blue-300">Pedal Pré-definido</h2>
            <div class="space-y-4">
                <div>
                    <label for="predefinedPedalSelect" class="block text-sm font-medium text-gray-300 mb-1">Selecione:</label>
                    <select id="predefinedPedalSelect" class="custom-select w-full">
                        <option value="">-- Selecione um Pedal --</option>
                    </select>
                </div>
            </div>

            <hr class="my-8 border-gray-700">

            <!-- ATUALIZADO: Configurações da Tela -->
            <h2 class="text-2xl font-semibold mb-4 text-blue-300">Configurações da Tela</h2>
            <div class="space-y-4">
                <div class="flex gap-4">
                    <div class="flex-1">
                        <label for="mainBoardWidthInput" class="block text-sm font-medium text-gray-300 mb-1">Largura:</label>
                        <input type="number" id="mainBoardWidthInput" class="input-field w-full" value="80" min="1">
                    </div>
                    <div class="flex-1">
                        <label for="mainBoardHeightInput" class="block text-sm font-medium text-gray-300 mb-1">Altura:</label>
                        <input type="number" id="mainBoardHeightInput" class="input-field w-full" value="40" min="1">
                    </div>
                </div>
                <button id="resetBoardViewBtn" class="btn btn-secondary w-full mt-4">Redefinir Visão da Tela</button>
            </div>

            <hr class="my-8 border-gray-700">

            <button id="clearBoardBtn" class="btn btn-danger w-full mt-4">Limpar Tudo</button>
        </aside>

        <!-- Área do Canvas (Pedalboard) -->
        <section id="canvas-section" class="absolute top-0 bottom-0 right-0 left-0 flex items-center justify-center transition-all duration-300 ease-in-out">
            <canvas id="pedalboardCanvas" class="rounded-lg"></canvas>
        </section>

        <!-- Toggle Button for Sidebar -->
        <button id="toggleSidebarBtn" class="fixed top-4 left-4 bg-blue-600 text-white p-2 rounded-md shadow-lg z-30">
            Menu
        </button>

        <!-- Fixed Share Button -->
        <button id="shareBoardBtn" title="Compartilhar Pedalboard">
            <i class="fas fa-share-alt"></i>
        </button>
    </main>

    <footer class="bg-gray-800 p-4 text-center text-gray-400 text-sm shadow-inner mt-4">
        &copy; 2025 Simulador de Pedalboard. Todos os direitos reservados.
    </footer>

    <!-- Share URL Modal -->
    <div id="shareModal" class="share-modal hidden"> <!-- Ensure it's hidden by default -->
        <div class="share-modal-content">
            <h3 class="text-xl font-semibold text-white mb-4">Compartilhe seu Pedalboard!</h3>
            <input type="text" id="shareUrlInput" readonly class="input-field mb-4">
            <button id="copyShareUrlBtn" class="btn btn-primary">Copiar URL</button>
            <button id="closeShareModalBtn" class="btn btn-secondary mt-2">Fechar</button>
        </div>
    </div>

    <script type="module">
        console.log("Script execution started.");
        // Firebase imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, addDoc, collection } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Your web app's Firebase configuration
        const firebaseConfig = {
            apiKey: "AIzaSyAHHDUwEtbydNom3TBrqvAfOINpAU01ma4",
            authDomain: "pedalboard-simulator.firebaseapp.com",
            projectId: "pedalboard-simulator",
            storageBucket: "pedalboard-simulator.firebasestorage.app",
            messagingSenderId: "649553293705",
            appId: "1:649553293705:web:b2f623fe263252264e7158",
            measurementId: "G-CS6EZM2X9M"
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        const appId = firebaseConfig.projectId; // Use projectId as appId for Firestore path consistency
        let userId = null; // Will store the authenticated user ID

        // Global variables for canvas elements and state
        let elements = []; // Array para armazenar todos os elementos (pedalboards e pedais)
        let isDragging = false;
        let draggedElement = null;
        let selectedElement = null; // Currently selected element
        let offsetXCm, offsetYCm; // Offset em cm
        let pixelsPerCm; // Scale, will be updated by resizeCanvas
        const moveIncrementCm = 0.5; // Incremento de movimento para atalhos de teclado em cm

        // Main board conceptual dimensions
        let effectiveBoardWidthCm = 80; // Default width of the conceptual board area in cm
        let effectiveBoardHeightCm = 40; // Default height of the conceptual board area in cm
        
        // Declare DOM element variables here, but assign them inside DOMContentLoaded
        let canvas, ctx, addBoardBtn, addPedalBtn, clearBoardBtn, shareBoardBtn;
        let boardNameInput, boardWidthInput, boardHeightInput;
        let pedalNameInput, pedalWidthInput, pedalHeightInput, pedalColorInput;
        let sidebar, toggleSidebarBtn, closeSidebarBtn, canvasSection; 
        let shareModal, shareUrlInput, copyShareUrlBtn, closeShareModalBtn;
        let predefinedBoardSelect, predefinedPedalSelect;
        // New DOM elements for Phase 4
        let mainBoardWidthInput, mainBoardHeightInput, resetBoardViewBtn;


        // --- Mock Data for Predefined Pedalboards ---
        const mockPedalboardData = [
            { name: "Standard 60x30", width: 60, height: 30, color: "#000000" },
            { name: "Compact 45x20", width: 45, height: 20, color: "#000000" },
            { name: "Large 80x40", width: 80, height: 40, color: "#000000" }
        ];

        // This will now be populated from pedals.json
        let predefinedPedalData = [];


        // --- Custom Alert Modal ---
        function showCustomAlert(message) {
            const modalId = 'custom-alert-modal';
            let modal = document.getElementById(modalId);

            if (!modal) {
                modal = document.createElement('div');
                modal.id = modalId;
                modal.className = 'fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-content-center z-50 p-4';
                modal.innerHTML = `
                    <div class="bg-gray-800 p-6 rounded-lg shadow-xl max-w-sm w-full text-center">
                        <p class="text-lg font-semibold text-white mb-4" id="custom-alert-message"></p>
                        <button id="custom-alert-ok-btn" class="px-4 py-2 rounded-md font-semibold focus:outline-none focus:ring-2 focus:ring-offset-2 bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500 w-full">OK</button>
                    </div>
                `;
                document.body.appendChild(modal);
            }

            document.getElementById('custom-alert-message').textContent = message;
            modal.classList.remove('hidden');

            document.getElementById('custom-alert-ok-btn').onclick = () => {
                modal.classList.add('hidden');
            };
        }

        /**
         * Converts a hexadecimal color string to its RGB components.
         * @param {string} hex - The hexadecimal color string (e.g., "#RRGGBB").
         * @returns {number[]} An array containing [R, G, B] values (0-255).
         */
        function hexToRgb(hex) {
            const r = parseInt(hex.substring(1, 3), 16);
            const g = parseInt(hex.substring(3, 5), 16);
            const b = parseInt(hex.substring(5, 7), 16);
            return [r, g, b];
        }

        /**
         * Calculates the relative luminance of an sRGB color.
         * Based on WCAG 2.0 formula.
         * @param {number} r - Red component (0-255).
         * @param {number} g - Green component (0-255).
         * @param {number} b - Blue component (0-255).
         * @returns {number} The relative luminance (0-1).
         */
        function getLuminance(r, g, b) {
            const sRGB = [r / 255, g / 255, b / 255];
            const linearRGB = sRGB.map(c => {
                if (c <= 0.03928) {
                    return c / 12.92;
                }
                return Math.pow((c + 0.055) / 1.055, 2.4);
            });
            return 0.2126 * linearRGB[0] + 0.7152 * linearRGB[1] + 0.0722 * linearRGB[2];
        }

        /**
         * Determines the best contrasting text color (black or white) for a given background color.
         * @param {string} backgroundColor - The background color in hexadecimal format (e.g., "#RRGGBB").
         * @returns {string} "#000000" (black) or "#FFFFFF" (white).
         */
        function getContrastColor(backgroundColor) {
            const [r, g, b] = hexToRgb(backgroundColor);
            const luminance = getLuminance(r, g, b);
            return luminance > 0.179 ? '#000000' : '#FFFFFF';
        }

        // Função para ajustar o tamanho do canvas e a escala, e desenhar elementos
        function resizeCanvas() {
            console.log("resizeCanvas() called.");
            if (!sidebar || !canvasSection || !canvas || !ctx) {
                console.warn("resizeCanvas: DOM elements not yet initialized.");
                return;
            }

            const headerHeight = document.querySelector('header').offsetHeight;
            const footerHeight = document.querySelector('footer').offsetHeight;

            const availableHeight = window.innerHeight - headerHeight - footerHeight;
            let availableWidth = window.innerWidth;
            const sidebarWidth = sidebar.offsetWidth;

            if (!sidebar.classList.contains('-translate-x-full')) {
                if (window.innerWidth >= 1024) {
                    availableWidth -= sidebarWidth;
                    canvasSection.style.left = `${sidebarWidth}px`;
                } else {
                    canvasSection.style.left = '0';
                }
            } else {
                canvasSection.style.left = '0';
            }

            canvas.width = availableWidth;
            canvas.height = availableHeight;

            // Adjust pixelsPerCm based on effective board dimensions to fit the canvas
            pixelsPerCm = Math.min(
                canvas.width / effectiveBoardWidthCm,
                canvas.height / effectiveBoardHeightCm
            );
            // Ensure a minimum scale if board dimensions are very small
            if (pixelsPerCm < 1) pixelsPerCm = 1;
            console.log(`resizeCanvas: new pixelsPerCm = ${pixelsPerCm.toFixed(2)}`);

            drawElements(); // Redraw elements with the new scale and background
        }

        /**
         * Converte polegadas (inches) para centímetros (cm).
         * * @param {number} inches O valor em polegadas a ser convertido.
         * @returns {number} O valor convertido em centímetros.
         */
        function inchesToCm(inches) {
            // 1 polegada = 2.54 centímetros
            const cm = inches * 2.54;
            return cm;
        }


        // Function to save elements to localStorage (fallback)
        function saveElements() {
            const simplifiedElements = elements.map(el => {
                const savedEl = { ...el }; // Copy all properties
                delete savedEl.image;
                delete savedEl.imageDataUrl;
                delete savedEl.originalWidth;
                delete savedEl.originalHeight;
                // Remove rotationIconRect and deleteIconRect from saved data
                delete savedEl.rotationIconRect;
                delete savedEl.deleteIconRect;
                return savedEl;
            });
            localStorage.setItem('pedalboardElements', JSON.stringify(simplifiedElements));
            // Also save main board settings
            const settings = {
                effectiveBoardWidthCm,
                effectiveBoardHeightCm
            };
            localStorage.setItem('pedalboardSettings', JSON.stringify(settings));
        }

        // Function to load elements and settings from localStorage (fallback)
        function loadElementsAndSettings() {
            const storedElements = localStorage.getItem('pedalboardElements');
            if (storedElements) {
                const loadedData = JSON.parse(storedElements);
                elements = []; // Clear current elements

                loadedData.forEach(data => {
                    const el = { ...data }; // Copy stored data
                    if (typeof el.currentRotationAngle === 'undefined') {
                        el.currentRotationAngle = 0;
                    }
                    delete el.image;
                    delete el.imageDataUrl;
                    delete el.originalWidth;
                    delete el.originalHeight;

                    elements.push(el);
                });
            }

            const storedSettings = localStorage.getItem('pedalboardSettings');
            if (storedSettings) {
                const settings = JSON.parse(storedSettings);
                effectiveBoardWidthCm = settings.effectiveBoardWidthCm || 80;
                effectiveBoardHeightCm = settings.effectiveBoardHeightCm || 40;

                // Update UI inputs with loaded settings
                if (mainBoardWidthInput) mainBoardWidthInput.value = effectiveBoardWidthCm;
                if (mainBoardHeightInput) mainBoardHeightInput.value = effectiveBoardHeightCm;
            }

            drawElements(); // Redraw after loading
        }


        /**
         * Saves the current pedalboard elements to Firestore for sharing.
         * @returns {Promise<string>} A promise that resolves with the unique ID of the shared pedalboard.
         */
        async function savePedalboardForSharing() {
            console.log("savePedalboardForSharing: Function called.");
            console.log("savePedalboardForSharing: State check - db:", db, "userId:", userId); // New debug log

            if (!db || !userId) {
                console.log("savePedalboardForSharing: Firebase or userId is not ready. Aborting save."); // More specific log
                showCustomAlert("Erro: Firebase não está pronto ou usuário não autenticado. Tente recarregar a página.");
                return null;
            }

            try {
                console.log("savePedalboardForSharing: Preparing elements for save.");
                const elementsToSave = elements.map(el => {
                    const { rotationIconRect, deleteIconRect, ...rest } = el;
                    return rest;
                });
                console.log("savePedalboardForSharing: Elements prepared. Attempting addDoc.");

                const docRef = await addDoc(collection(db, `artifacts/${appId}/public/data/shared_pedalboards`), {
                    elements: JSON.stringify(elementsToSave), // Stringify to handle complex array of objects
                    effectiveBoardWidthCm: effectiveBoardWidthCm,
                    effectiveBoardHeightCm: effectiveBoardHeightCm,
                    createdAt: new Date(),
                    ownerId: userId // Store owner for potential future features
                });
                console.log("savePedalboardForSharing: docRef object after addDoc:", docRef); // NEW LOG
                console.log("savePedalboardForSharing: Pedalboard saved to Firestore with ID:", docRef.id);
                return docRef.id;
            } catch (e) {
                console.error("savePedalboardForSharing: Caught error adding document to Firestore: ", e); // More explicit log
                showCustomAlert("Erro ao salvar o pedalboard para compartilhamento. Verifique as regras de segurança do Firestore e sua conexão."); // More helpful alert
                return null;
            } finally { // NEW FINALLY BLOCK
                console.log("savePedalboardForSharing: Function finished execution.");
            }
        }

        /**
         * Loads a pedalboard from Firestore using a boardId from the URL.
         * This function is called after Firebase authentication is complete.
         */
        async function loadPedalboardFromUrl() {
            const urlParams = new URLSearchParams(window.location.search);
            const boardId = urlParams.get('boardId');

            if (boardId && db) {
                console.log("loadPedalboardFromUrl: Attempting to load shared pedalboard with ID:", boardId);
                try {
                    const docRef = doc(db, `artifacts/${appId}/public/data/shared_pedalboards`, boardId);
                    const docSnap = await getDoc(docRef);

                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        // Parse the stringified elements back into an array of objects
                        elements = JSON.parse(data.elements || '[]');
                        // Load main board settings from shared data
                        effectiveBoardWidthCm = data.effectiveBoardWidthCm || 80;
                        effectiveBoardHeightCm = data.effectiveBoardHeightCm || 40;

                        // Update UI inputs with loaded settings
                        if (mainBoardWidthInput) mainBoardWidthInput.value = effectiveBoardWidthCm;
                        if (mainBoardHeightInput) mainBoardHeightInput.value = effectiveBoardHeightCm;

                        drawElements();
                        showCustomAlert("Pedalboard compartilhado carregado com sucesso!");
                        console.log("loadPedalboardFromUrl: Shared pedalboard loaded successfully.");
                    } else {
                        console.log("loadPedalboardFromUrl: No such shared pedalboard document found for ID:", boardId);
                        showCustomAlert("Pedalboard compartilhado não encontrado. Carregando seu último layout salvo localmente.");
                        loadElementsAndSettings(); // Fallback to local storage if shared board not found
                    }
                } catch (error) {
                    console.error("loadPedalboardFromUrl: Error getting shared document from Firestore:", error);
                    showCustomAlert("Erro ao carregar o pedalboard compartilhado. Carregando seu último layout salvo localmente.");
                    loadElementsAndSettings(); // Fallback on error
                }
            } else {
                console.log("loadPedalboardFromUrl: No boardId in URL or Firebase not ready. Loading local elements.");
                // If no boardId in URL, load from local storage
                loadElementsAndSettings();
            }
            // resizeCanvas() is now called by DOMContentLoaded or window resize listener
        }

        /**
         * Rotates a point (px, py) around a center (cx, cy) by a given angle.
         * @param {number} px - X coordinate of the point.
         * @param {number} py - Y coordinate of the point.
         * @param {number} cx - X coordinate of the rotation center.
         * @param {number} cy - Y coordinate of the rotation center.
         * @param {number} angle - Rotation angle in radians.
         * @returns {{x: number, y: number}} The new coordinates of the rotated point.
         */
        function rotatePoint(px, py, cx, cy, angle) {
            const cos = Math.cos(angle);
            const sin = Math.sin(angle);
            const nx = cx + (px - cx) * cos - (py - cy) * sin;
            const ny = cy + (px - cx) * sin + (py - cy) * cos;
            return { x: nx, y: ny };
        }


        // Function to draw all elements on the canvas
        function drawElements() {
            if (!ctx || !canvas) {
                console.warn("drawElements: Canvas context or canvas element not initialized.");
                return;
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear the canvas

            // Draw a background for the entire canvas area using the fixed background color
            ctx.fillStyle = getComputedStyle(canvas).backgroundColor; // Get color from CSS
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Calculate the position to center the conceptual effectiveBoardWidthCm x effectiveBoardHeightCm area
            // within the actual canvas, considering current pixelsPerCm.
            const displayBoardWidthPx = effectiveBoardWidthCm * pixelsPerCm;
            const displayBoardHeightPx = effectiveBoardHeightCm * pixelsPerCm;

            const boardOffsetX = (canvas.width - displayBoardWidthPx) / 2;
            const boardOffsetY = (canvas.height - displayBoardHeightPx) / 2;

            // Draw a border for the conceptual board area
            ctx.strokeStyle = '#6B7280'; // Gray border for the conceptual board area
            ctx.lineWidth = 2;
            ctx.strokeRect(boardOffsetX, boardOffsetY, displayBoardWidthPx, displayBoardHeightPx);


            // Draw elements: boards first (background), then pedals (foreground)
            elements.sort((a, b) => (a.isBoard === b.isBoard) ? 0 : a.isBoard ? -1 : 1).forEach(el => {
                // Save the current canvas state before applying transformations
                ctx.save();

                const originalWidthPx = el.width * pixelsPerCm;
                const originalHeightPx = el.height * pixelsPerCm;
                // Position elements relative to the conceptual board's origin
                const xPx = el.x * pixelsPerCm + boardOffsetX;
                const yPx = el.y * pixelsPerCm + boardOffsetY;

                // Calculate center of the element for rotation
                const centerX = xPx + originalWidthPx / 2;
                const centerY = yPx + originalHeightPx / 2;

                // Translate to center, rotate, then translate back
                ctx.translate(centerX, centerY);
                ctx.rotate(el.currentRotationAngle);
                ctx.translate(-centerX, -centerY);

                // Draw element color
                ctx.fillStyle = el.color;
                ctx.fillRect(xPx, yPx, originalWidthPx, originalHeightPx);

                // Determine text color based on background color
                const textColor = getContrastColor(el.color);
                ctx.fillStyle = textColor;

                // Draw element name
                ctx.font = `${(el.isBoard ? 16 : 12)}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle'; // Align text vertically in the middle
                ctx.fillText(el.name, xPx + originalWidthPx / 2, yPx + originalHeightPx / 2 - (el.isBoard ? 8 : 5)); // Adjusted Y for dimensions below

                // Draw dimensions below the name
                ctx.font = `${(el.isBoard ? 10 : 9)}px Inter`;
                ctx.fillText(`${el.width.toFixed(1)}x${el.height.toFixed(1)} cm`, xPx + originalWidthPx / 2, yPx + originalHeightPx / 2 + (el.isBoard ? 8 : 5));


                // Draw element border
                if (selectedElement && selectedElement.id === el.id) {
                    ctx.strokeStyle = '#a78bfa'; // Purple for selected
                    ctx.lineWidth = el.isBoard ? 5 : 4; // Thicker border for selected
                } else {
                    ctx.strokeStyle = el.isBoard ? '#718096' : '#cbd5e0'; // Different border color for board
                    ctx.lineWidth = el.isBoard ? 3 : 2; // Different border thickness for board
                }
                ctx.strokeRect(xPx, yPx, originalWidthPx, originalHeightPx);

                // Restore the canvas state to remove transformations for the next element
                ctx.restore();

                // Draw rotation and delete icons if element is selected (outside of ctx.save/restore block)
                // These icons should not rotate with the element, but stay relative to the canvas.
                if (selectedElement && selectedElement.id === el.id) {
                    const iconSizePx = 28;

                    // Calculate the four corners of the UNROTATED rectangle in canvas pixels, adjusted for boardOffsetX/Y
                    const p1 = { x: el.x * pixelsPerCm + boardOffsetX, y: el.y * pixelsPerCm + boardOffsetY };
                    const p2 = { x: (el.x + el.width) * pixelsPerCm + boardOffsetX, y: el.y * pixelsPerCm + boardOffsetY };
                    const p3 = { x: el.x * pixelsPerCm + boardOffsetX, y: (el.y + el.height) * pixelsPerCm + boardOffsetY };
                    const p4 = { x: (el.x + el.width) * pixelsPerCm + boardOffsetX, y: (el.y + el.height) * pixelsPerCm + boardOffsetY };

                    // Center of rotation for the element in canvas pixels, adjusted for boardOffsetX/Y
                    const rotCenterX = p1.x + (el.width * pixelsPerCm) / 2;
                    const rotCenterY = p1.y + (el.height * pixelsPerCm) / 2;
                    const angle = el.currentRotationAngle;

                    // Rotate the four corners to find the bounding box of the rotated element
                    const allX = [rotatedP1.x, rotatedP2.x, rotatedP3.x, rotatedP4.x];
                    const allY = [rotatedP1.y, rotatedP2.y, rotatedP3.y, rotatedP4.y];

                    const minBoundX = Math.min(...allX);
                    const maxBoundX = Math.max(...allX);
                    const minBoundY = Math.min(...allY);
                    const maxBoundY = Math.max(...allY);

                    // Now, position the icons relative to this calculated bounding box
                    // --- Rotation Icon (Top-Right of Bounding Box) ---
                    const rotationIconX = maxBoundX - iconSizePx / 2;
                    const rotationIconY = minBoundY - iconSizePx / 2;

                    selectedElement.rotationIconRect = {
                        x: rotationIconX,
                        y: rotationIconY,
                        width: iconSizePx,
                        height: iconSizePx
                    };

                    ctx.fillStyle = '#6366f1'; // Indigo color
                    ctx.beginPath();
                    ctx.arc(rotationIconX + iconSizePx / 2, rotationIconY + iconSizePx / 2, iconSizePx / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#e2e8f0';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    ctx.fillStyle = '#e2e8f0';
                    ctx.font = `${iconSizePx * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('↻', rotationIconX + iconSizePx / 2, rotationIconY + iconSizePx / 2 + 1);

                    // --- Delete Icon (Top-Left of Bounding Box) ---
                    const deleteIconX = minBoundX - iconSizePx / 2;
                    const deleteIconY = minBoundY - iconSizePx / 2;

                    selectedElement.deleteIconRect = {
                        x: deleteIconX,
                        y: deleteIconY,
                        width: iconSizePx,
                        height: iconSizePx
                    };

                    ctx.fillStyle = '#ef4444'; // Red color
                    ctx.beginPath();
                    ctx.arc(deleteIconX + iconSizePx / 2, deleteIconY + iconSizePx / 2, iconSizePx / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.strokeStyle = '#e2e8f0';
                    ctx.lineWidth = 1;
                    ctx.stroke();

                    ctx.fillStyle = '#e2e8f0';
                    ctx.font = `${iconSizePx * 0.7}px sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('X', deleteIconX + iconSizePx / 2, deleteIconY + iconSizePx / 2 + 1);
                } else {
                    if (el.rotationIconRect) {
                        delete el.rotationIconRect;
                    }
                    if (el.deleteIconRect) {
                        delete el.deleteIconRect;
                    }
                }
            });
        }

        // Drag and drop logic (Mouse)
        function setupCanvasMouseEvents() {
            canvas.addEventListener('mousedown', (e) => {
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Calculate the conceptual board's offset within the canvas
                const displayBoardWidthPx = effectiveBoardWidthCm * pixelsPerCm;
                const displayBoardHeightPx = effectiveBoardHeightCm * pixelsPerCm;
                const boardOffsetX = (canvas.width - displayBoardWidthPx) / 2;
                const boardOffsetY = (canvas.height - displayBoardHeightPx) / 2;

                // Adjust mouse coordinates to be relative to the conceptual board's origin
                const mouseXAdjusted = mouseX - boardOffsetX;
                const mouseYAdjusted = mouseY - boardOffsetY;

                const mouseXCm = mouseXAdjusted / pixelsPerCm;
                const mouseYCm = mouseYAdjusted / pixelsPerCm;

                // Check if clicked on delete icon first
                if (selectedElement && selectedElement.deleteIconRect) {
                    const iconRect = selectedElement.deleteIconRect;
                    if (mouseX >= iconRect.x && mouseX <= iconRect.x + iconRect.width &&
                        mouseY >= iconRect.y && mouseY <= iconRect.y + iconRect.height) {
                        const indexToRemove = elements.findIndex(el => el.id === selectedElement.id);
                        if (indexToRemove !== -1) {
                            elements.splice(indexToRemove, 1);
                            selectedElement = null;
                            drawElements();
                            saveElements();
                        }
                        isDragging = false;
                        draggedElement = null;
                        canvas.classList.remove('dragging');
                        return;
                    }
                }

                // Check if clicked on rotation icon
                if (selectedElement && selectedElement.rotationIconRect) {
                    const iconRect = selectedElement.rotationIconRect;
                    if (mouseX >= iconRect.x && mouseX <= iconRect.x + iconRect.width &&
                        mouseY >= iconRect.y && mouseY <= iconRect.y + iconRect.height) {
                        // Update rotation angle by 90 degrees (PI/2 radians)
                        selectedElement.currentRotationAngle = (selectedElement.currentRotationAngle + Math.PI / 2) % (2 * Math.PI);
                        drawElements();
                        saveElements();
                        isDragging = false;
                        draggedElement = null;
                        canvas.classList.remove('dragging');
                        return;
                    }
                }

                let clickedOnElement = false;
                // Iterate over elements from back to front to pick the top element
                for (let i = elements.length - 1; i >= 0; i--) {
                    const el = elements[i];
                    
                    // Calculate the four corners of the UNROTATED rectangle in canvas pixels, adjusted for boardOffsetX/Y
                    const p1 = { x: el.x * pixelsPerCm + boardOffsetX, y: el.y * pixelsPerCm + boardOffsetY };
                    const p2 = { x: (el.x + el.width) * pixelsPerCm + boardOffsetX, y: el.y * pixelsPerCm + boardOffsetY };
                    const p3 = { x: el.x * pixelsPerCm + boardOffsetX, y: (el.y + el.height) * pixelsPerCm + boardOffsetY };
                    const p4 = { x: (el.x + el.width) * pixelsPerCm + boardOffsetX, y: (el.y + el.height) * pixelsPerCm + boardOffsetY };

                    // Center of rotation for the element in canvas pixels, adjusted for boardOffsetX/Y
                    const rotCenterX = p1.x + (el.width * pixelsPerCm) / 2;
                    const rotCenterY = p1.y + (el.height * pixelsPerCm) / 2;
                    const angle = el.currentRotationAngle;

                    // Rotate the four corners
                    const rotatedP1 = rotatePoint(p1.x, p1.y, rotCenterX, rotCenterY, angle);
                    const rotatedP2 = rotatePoint(p2.x, p2.y, rotCenterX, rotCenterY, angle);
                    const rotatedP3 = rotatePoint(p3.x, p3.y, rotCenterX, rotCenterY, angle);
                    const rotatedP4 = rotatePoint(p4.x, p4.y, rotCenterX, rotCenterY, angle);

                    // Find the min/max X and Y to get the bounding box of the rotated element
                    const allX = [rotatedP1.x, rotatedP2.x, rotatedP3.x, rotatedP4.x];
                    const allY = [rotatedP1.y, rotatedP2.y, rotatedP3.y, rotatedP4.y];

                    const minBoundX = Math.min(...allX);
                    const maxBoundX = Math.max(...allX);
                    const minBoundY = Math.min(...allY);
                    const maxBoundY = Math.max(...allY);

                    // If mouseX/Y is within this rotated bounding box
                    if (mouseX >= minBoundX && mouseX <= maxBoundX &&
                        mouseY >= minBoundY && mouseY <= maxBoundY) {
                        isDragging = true;
                        draggedElement = el;
                        selectedElement = el; // Set selected element
                        clickedOnElement = true;

                        // Calculate offset in cm relative to the element's original top-left corner
                        // Use mouseXCm and mouseYCm directly for offset calculation
                        offsetXCm = mouseXCm - el.x;
                        offsetYCm = mouseYCm - el.y;
                        canvas.classList.add('dragging');

                        // Move the dragged element to the end of the array so it's drawn last (on top)
                        // Except if it's a board and there are other non-board elements on top of it
                        if (!el.isBoard) { // Only move pedais to the top
                            elements.splice(i, 1);
                            elements.push(draggedElement);
                        } else { // If it's a board, check if there are pedais on top of it
                            const hasPedalsAbove = elements.slice(i + 1).some(otherEl => !otherEl.isBoard &&
                                (otherEl.x < el.x + el.width && otherEl.x + el.width > el.x &&
                                 otherEl.y < el.y + el.height && otherEl.y + el.height > el.y)
                            );
                            if (hasPedalsAbove) {
                                isDragging = false;
                                draggedElement = null;
                                canvas.classList.remove('dragging');
                                showCustomAlert('Não é possível arrastar o pedalboard enquanto houver pedais em cima dele.');
                                return;
                            }
                            elements.splice(i, 1);
                            const firstPedalIndex = elements.findIndex(item => !item.isBoard);
                            if (firstPedalIndex !== -1) {
                                elements.splice(firstPedalIndex, 0, draggedElement);
                            } else {
                                elements.push(draggedElement);
                            }
                        }
                        drawElements();
                        break;
                    }
                }
                if (!clickedOnElement) {
                    selectedElement = null; // Limpa a seleção se clicou fora dos elementos
                    drawElements(); // Redesenha para remover o destaque de seleção
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (!isDragging || !draggedElement) return;

                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                // Calculate the conceptual board's offset within the canvas
                const displayBoardWidthPx = effectiveBoardWidthCm * pixelsPerCm;
                const displayBoardHeightPx = effectiveBoardHeightCm * pixelsPerCm;
                const boardOffsetX = (canvas.width - displayBoardWidthPx) / 2;
                const boardOffsetY = (canvas.height - displayBoardHeightPx) / 2;

                // Adjust mouse coordinates to be relative to the conceptual board's origin
                const mouseXAdjusted = mouseX - boardOffsetX;
                const mouseYAdjusted = mouseY - boardOffsetY;

                // Convert adjusted mouse coordinates from pixels to cm
                const mouseXCm = mouseXAdjusted / pixelsPerCm;
                const mouseYCm = mouseYAdjusted / pixelsPerCm;

                // Calculate new element position in cm
                let newXCm = mouseXCm - offsetXCm;
                let newYCm = mouseYCm - offsetYCm;

                // Limit the element within the conceptual board boundaries (in cm)
                const elementWidthCm = draggedElement.width;
                const elementHeightCm = draggedElement.height;

                newXCm = Math.max(0, Math.min(newXCm, effectiveBoardWidthCm - elementWidthCm));
                newYCm = Math.max(0, Math.min(newYCm, effectiveBoardHeightCm - elementHeightCm));

                draggedElement.x = newXCm;
                draggedElement.y = newYCm;

                drawElements();
            });

            canvas.addEventListener('mouseup', () => {
                isDragging = false;
                draggedElement = null;
                canvas.classList.remove('dragging');
                drawElements();
                saveElements(); // Salva após soltar
            });

            canvas.addEventListener('mouseout', () => {
                // If mouse leaves the canvas while dragging, drop the element
                if (isDragging) {
                    isDragging = false;
                    draggedElement = null;
                    canvas.classList.remove('dragging');
                    drawElements();
                    saveElements(); // Save if dragging stops by leaving canvas
                }
            });
        }

        // Drag and drop logic for touch (Touch)
        function setupCanvasTouchEvents() {
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent page scrolling
                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;

                // Calculate the conceptual board's offset within the canvas
                const displayBoardWidthPx = effectiveBoardWidthCm * pixelsPerCm;
                const displayBoardHeightPx = effectiveBoardHeightCm * pixelsPerCm;
                const boardOffsetX = (canvas.width - displayBoardWidthPx) / 2;
                const boardOffsetY = (canvas.height - displayBoardHeightPx) / 2;

                // Adjust touch coordinates to be relative to the conceptual board's origin
                const touchXAdjusted = touchX - boardOffsetX;
                const touchYAdjusted = touchY - boardOffsetY;

                // Converte as coordenadas do toque de pixels para cm usando a escala fixa
                const touchXCm = touchXAdjusted / pixelsPerCm;
                const touchYCm = touchYAdjusted / pixelsPerCm;

                // Check if clicked on delete icon first
                if (selectedElement && selectedElement.deleteIconRect) {
                    const iconRect = selectedElement.deleteIconRect;
                    if (touchX >= iconRect.x && touchX <= iconRect.x + iconRect.width &&
                        touchY >= iconRect.y && touchY <= iconRect.y + iconRect.height) {
                        const indexToRemove = elements.findIndex(el => el.id === selectedElement.id);
                        if (indexToRemove !== -1) {
                            elements.splice(indexToRemove, 1);
                            selectedElement = null;
                            drawElements();
                            saveElements();
                        }
                        isDragging = false;
                        draggedElement = null;
                        canvas.classList.remove('dragging');
                        return;
                    }
                }

                // Check if clicked on rotation icon
                if (selectedElement && selectedElement.rotationIconRect) {
                    const iconRect = selectedElement.rotationIconRect;
                    if (touchX >= iconRect.x && touchX <= iconRect.x + iconRect.width &&
                        touchY >= iconRect.y && touchY <= iconRect.y + iconRect.height) {
                        // Update rotation angle by 90 degrees (PI/2 radians)
                        selectedElement.currentRotationAngle = (selectedElement.currentRotationAngle + Math.PI / 2) % (2 * Math.PI);
                        drawElements();
                        saveElements();
                        isDragging = false;
                        draggedElement = null;
                        canvas.classList.remove('dragging');
                        return;
                    }
                }

                let clickedOnElement = false;
                for (let i = elements.length - 1; i >= 0; i--) {
                    const el = elements[i];

                    // Calculate the four corners of the UNROTATED rectangle in canvas pixels, adjusted for boardOffsetX/Y
                    const p1 = { x: el.x * pixelsPerCm + boardOffsetX, y: el.y * pixelsPerCm + boardOffsetY };
                    const p2 = { x: (el.x + el.width) * pixelsPerCm + boardOffsetX, y: el.y * pixelsPerCm + boardOffsetY };
                    const p3 = { x: el.x * pixelsPerCm + boardOffsetX, y: (el.y + el.height) * pixelsPerCm + boardOffsetY };
                    const p4 = { x: (el.x + el.width) * pixelsPerCm + boardOffsetX, y: (el.y + el.height) * pixelsPerCm + boardOffsetY };

                    // Center of rotation for the element in canvas pixels, adjusted for boardOffsetX/Y
                    const rotCenterX = p1.x + (el.width * pixelsPerCm) / 2;
                    const rotCenterY = p1.y + (el.height * pixelsPerCm) / 2;
                    const angle = el.currentRotationAngle;

                    // Rotate the four corners
                    const rotatedP1 = rotatePoint(p1.x, p1.y, rotCenterX, rotCenterY, angle);
                    const rotatedP2 = rotatePoint(p2.x, p2.y, rotCenterX, rotCenterY, angle);
                    const rotatedP3 = rotatePoint(p3.x, p3.y, rotCenterX, rotCenterY, angle);
                    const rotatedP4 = rotatePoint(p4.x, p4.y, rotCenterX, rotCenterY, angle);

                    // Find the min/max X and Y to get the bounding box of the rotated element
                    const allX = [rotatedP1.x, rotatedP2.x, rotatedP3.x, rotatedP4.x];
                    const allY = [rotatedP1.y, rotatedP2.y, rotatedP3.y, rotatedP4.y];

                    const minBoundX = Math.min(...allX);
                    const maxBoundX = Math.max(...allX);
                    const minBoundY = Math.min(...allY);
                    const maxBoundY = Math.max(...allY);

                    // If touchX/Y is within this rotated bounding box
                    if (touchX >= minBoundX && touchX <= maxBoundX &&
                        touchY >= minBoundY && touchY <= maxBoundY) {
                        isDragging = true;
                        draggedElement = el;
                        selectedElement = el;
                        clickedOnElement = true;

                        offsetXCm = touchXCm - el.x;
                        offsetYCm = touchYCm - el.y;
                        canvas.classList.add('dragging');

                        if (!el.isBoard) {
                            elements.splice(i, 1);
                            elements.push(draggedElement);
                        } else {
                            const hasPedalsAbove = elements.slice(i + 1).some(otherEl => !otherEl.isBoard &&
                                (otherEl.x < el.x + el.width && otherEl.x + el.width > el.x &&
                                 otherEl.y < el.y + el.height && otherEl.y + el.height > el.y)
                            );
                            if (hasPedalsAbove) {
                                isDragging = false;
                                draggedElement = null;
                                canvas.classList.remove('dragging');
                                showCustomAlert('Não é possível arrastar o pedalboard enquanto houver pedais em cima dele.');
                                return;
                            }
                            elements.splice(i, 1);
                            const firstPedalIndex = elements.findIndex(item => !item.isBoard);
                            if (firstPedalIndex !== -1) {
                                elements.splice(firstPedalIndex, 0, draggedElement);
                            } else {
                                elements.push(draggedElement);
                            }
                        }
                        drawElements();
                        break;
                    }
                }
                if (!clickedOnElement) {
                    selectedElement = null;
                    drawElements();
                }
            });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (!isDragging || !draggedElement) return;

                const touch = e.touches[0];
                const rect = canvas.getBoundingClientRect();
                const touchX = touch.clientX - rect.left;
                const touchY = touch.clientY - rect.top;

                // Calculate the conceptual board's offset within the canvas
                const displayBoardWidthPx = effectiveBoardWidthCm * pixelsPerCm;
                const displayBoardHeightPx = effectiveBoardHeightCm * pixelsPerCm;
                const boardOffsetX = (canvas.width - displayBoardWidthPx) / 2;
                const boardOffsetY = (canvas.height - displayBoardHeightPx) / 2;

                // Adjust touch coordinates to be relative to the conceptual board's origin
                const touchXAdjusted = touchX - boardOffsetX;
                const touchYAdjusted = touchY - boardOffsetY;

                const touchXCm = touchXAdjusted / pixelsPerCm;
                const touchYCm = touchYAdjusted / pixelsPerCm;

                let newXCm = touchXCm - offsetXCm;
                let newYCm = touchYCm - offsetYCm;

                const elementWidthCm = draggedElement.width;
                const elementHeightCm = draggedElement.height;

                newXCm = Math.max(0, Math.min(newXCm, effectiveBoardWidthCm - elementWidthCm));
                newYCm = Math.max(0, Math.min(newYCm, effectiveBoardHeightCm - elementHeightCm));

                draggedElement.x = newXCm;
                draggedElement.y = newYCm;

                drawElements();
            });

            canvas.addEventListener('touchend', () => {
                isDragging = false;
                draggedElement = null;
                canvas.classList.remove('dragging');
                drawElements();
                saveElements();
            });
        }

        // Functions to populate dropdowns
        function populatePedalboardDropdown() {
            if (!predefinedBoardSelect) return;
            predefinedBoardSelect.innerHTML = '<option value="">-- Selecione um Pedalboard --</option>'; // Clear existing options
            mockPedalboardData.forEach(board => {
                const option = document.createElement('option');
                option.value = JSON.stringify(board); // Store object as string
                option.textContent = `${board.name} (${board.width}x${board.height} cm)`;
                predefinedBoardSelect.appendChild(option);
            });
        }

        // Updated function to populate pedal dropdown from `predefinedPedalData`
        function populatePedalDropdown() {
            if (!predefinedPedalSelect) return;
            predefinedPedalSelect.innerHTML = '<option value="">-- Selecione um Pedal --</option>'; // Clear existing options
            predefinedPedalData.forEach(pedal => {
                const option = document.createElement('option');
                option.value = JSON.stringify(pedal); // Store object as string
                option.textContent = `${pedal.Name} (${inchesToCm(pedal.Width).toFixed(1)}x${inchesToCm(pedal.Height).toFixed(1)} cm)`;
                predefinedPedalSelect.appendChild(option);
            });
        }

        // Function to fetch pedal data from pedals.json
        async function fetchPedalsData() {
            try {
                // Simulate fetching from 'pedals.json'. In a real scenario, this would be a fetch call:
                const response = await fetch('pedals.json');
                const data = await response.json();
                
                // For demonstration, use hardcoded data directly
                /* const data = [
                    { name: "Overdrive (Std)", width: 7, height: 12, color: "#DB2777" }, // Pink
                    { name: "Distortion (Std)", width: 7, height: 12, color: "#EF4444" }, // Red
                    { name: "Delay (Big)", width: 10, height: 15, color: "#3B82F6" },    // Blue
                    { name: "Reverb (Compact)", width: 6, height: 10, color: "#10B981" }, // Green
                    { name: "Wah (Large)", width: 11, height: 25, color: "#F59E0B" },     // Amber
                    { name: "Chorus (Small)", width: 6, height: 11, color: "#FFD700" }, // Gold
                    { name: "Fuzz (Square)", width: 8, height: 8, color: "#800080" }, // Purple
                    { name: "Compressor (Mini)", width: 5, height: 9, color: "#00CED1" } // Dark Cyan
                ]; */
                predefinedPedalData = data;
                populatePedalDropdown();
            } catch (error) {
                console.error("Erro ao carregar dados de pedais:", error);
                showCustomAlert("Erro ao carregar a lista de pedais pré-definidos.");
            }
        }

        // Keyboard event handler for shortcuts
        function handleKeyDown(e) {
            if (!selectedElement) return; // Only act if an element is selected

            let changed = false;
            let currentX = selectedElement.x;
            let currentY = selectedElement.y;

            // Get current dimensions for boundary checks
            const elementWidthCm = selectedElement.width;
            const elementHeightCm = selectedElement.height;

            switch (e.key) {
                case 'Delete':
                case 'Backspace':
                    e.preventDefault(); // Prevent browser back navigation for Backspace
                    const indexToRemove = elements.findIndex(el => el.id === selectedElement.id);
                    if (indexToRemove !== -1) {
                        elements.splice(indexToRemove, 1);
                        selectedElement = null; // Deselect after deletion
                        changed = true;
                    }
                    break;
                case 'r': // 'r' for rotate (case-insensitive)
                case 'R':
                    e.preventDefault();
                    selectedElement.currentRotationAngle = (selectedElement.currentRotationAngle + Math.PI / 2) % (2 * Math.PI);
                    changed = true;
                    break;
                case 'ArrowUp':
                    e.preventDefault();
                    currentY = Math.max(0, currentY - moveIncrementCm);
                    if (selectedElement.y !== currentY) {
                        selectedElement.y = currentY;
                        changed = true;
                    }
                    break;
                case 'ArrowDown':
                    e.preventDefault();
                    currentY = Math.min(effectiveBoardHeightCm - elementHeightCm, currentY + moveIncrementCm);
                    if (selectedElement.y !== currentY) {
                        selectedElement.y = currentY;
                        changed = true;
                    }
                    break;
                case 'ArrowLeft':
                    e.preventDefault();
                    currentX = Math.max(0, currentX - moveIncrementCm);
                    if (selectedElement.x !== currentX) {
                        selectedElement.x = currentX;
                        changed = true;
                    }
                    break;
                case 'ArrowRight':
                    e.preventDefault();
                    currentX = Math.min(effectiveBoardWidthCm - elementWidthCm, currentX + moveIncrementCm);
                    if (selectedElement.x !== currentX) {
                        selectedElement.x = currentX;
                        changed = true;
                    }
                    break;
            }

            if (changed) {
                drawElements();
                saveElements();
            }
        }


        // Authenticate anonymously
        signInAnonymously(auth)
            .then((userCredential) => {
                userId = userCredential.user.uid;
                console.log("Firebase initialized and user authenticated with ID:", userId);
                loadPedalboardFromUrl(); // Now that Firebase is ready, try to load from URL
            })
            .catch((error) => {
                console.error("Error signing in anonymously:", error);
                showCustomAlert("Erro ao autenticar no Firebase. Algumas funcionalidades podem não estar disponíveis.");
                userId = null; // Ensure userId is null if auth fails
                loadElementsAndSettings(); // Fallback to local storage if Firebase fails
            });

        // Event listener for DOMContentLoaded to ensure all HTML elements are loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOMContentLoaded fired. Initializing DOM element references and event listeners.");
            canvas = document.getElementById('pedalboardCanvas');
            ctx = canvas.getContext('2d');

            addBoardBtn = document.getElementById('addBoardBtn');
            addPedalBtn = document.getElementById('addPedalBtn');
            clearBoardBtn = document.getElementById('clearBoardBtn');
            shareBoardBtn = document.getElementById('shareBoardBtn');

            boardNameInput = document.getElementById('boardName');
            boardWidthInput = document.getElementById('boardWidth');
            boardHeightInput = document.getElementById('boardHeight');

            pedalNameInput = document.getElementById('pedalName');
            pedalWidthInput = document.getElementById('pedalWidth');
            pedalHeightInput = document.getElementById('pedalHeight');
            pedalColorInput = document.getElementById('pedalColor');

            sidebar = document.getElementById('sidebar');
            toggleSidebarBtn = document.getElementById('toggleSidebarBtn');
            closeSidebarBtn = document.getElementById('closeSidebarBtn');
            canvasSection = document.getElementById('canvas-section');

            shareModal = document.getElementById('shareModal');
            shareUrlInput = document.getElementById('shareUrlInput');
            copyShareUrlBtn = document.getElementById('copyShareUrlBtn');
            closeShareModalBtn = document.getElementById('closeShareModalBtn');

            // New predefined dropdowns and buttons (references still needed even if buttons are removed from HTML)
            predefinedBoardSelect = document.getElementById('predefinedBoardSelect');
            predefinedPedalSelect = document.getElementById('predefinedPedalSelect');

            // Phase 4 - New DOM elements references
            mainBoardWidthInput = document.getElementById('mainBoardWidthInput');
            mainBoardHeightInput = document.getElementById('mainBoardHeightInput');
            resetBoardViewBtn = document.getElementById('resetBoardViewBtn');

            // Populate dropdowns on load
            populatePedalboardDropdown();
            fetchPedalsData(); // Fetch and populate pedal dropdown


            // Load initial settings and elements
            loadElementsAndSettings(); // This will also update the UI inputs.


            // Attach all event listeners here, after elements are guaranteed to exist
            addBoardBtn.addEventListener('click', () => {
                const name = boardNameInput.value.trim();
                const width = parseFloat(boardWidthInput.value);
                const height = parseFloat(boardHeightInput.value);

                if (!name || isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
                    showCustomAlert('Por favor, preencha o nome, largura e altura do pedalboard corretamente.');
                    return;
                }

                const newBoard = {
                    id: Date.now(),
                    name: name,
                    width: width,
                    height: height,
                    x: (effectiveBoardWidthCm / 2) - (width / 2), // Position in center of conceptual board
                    y: (effectiveBoardHeightCm / 2) - (height / 2), // Position in center of conceptual board
                    color: '#000000', // Fixed to black
                    isBoard: true, // Property to identify as a board
                    currentRotationAngle: 0 // Initialize rotation angle
                };

                elements.push(newBoard);
                drawElements();
                saveElements(); // Save after adding
                // Clear input fields
                boardNameInput.value = '';
                boardWidthInput.value = '60';
                boardHeightInput.value = '30';
            });

            addPedalBtn.addEventListener('click', () => {
                const name = pedalNameInput.value.trim();
                const width = parseFloat(pedalWidthInput.value);
                const height = parseFloat(pedalHeightInput.value);
                const color = pedalColorInput.value;

                if (!name || isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
                    showCustomAlert('Por favor, preencha o nome, largura e altura do pedal corretamente.');
                    return;
                }

                const newPedal = {
                    id: Date.now(),
                    name: name,
                    width: width,
                    height: height,
                    x: (effectiveBoardWidthCm / 2) - (width / 2), // Position in center of conceptual board
                    y: (effectiveBoardHeightCm / 2) - (height / 2), // Position in center of conceptual board
                    color: color,
                    isBoard: false, // Property to identify as a pedal
                    currentRotationAngle: 0 // Initialize rotation angle
                };

                elements.push(newPedal);
                drawElements();
                saveElements(); // Save after adding
                // Clear input fields
                pedalNameInput.value = '';
                pedalWidthInput.value = '7';
                pedalHeightInput.value = '12';
                pedalColorInput.value = '#3498db';
            });

            // Event listener for adding predefined pedalboard (now on change)
            predefinedBoardSelect.addEventListener('change', () => {
                const selectedOptionValue = predefinedBoardSelect.value;
                if (!selectedOptionValue) {
                    return; // Do nothing if the placeholder option is selected
                }
                const boardData = JSON.parse(selectedOptionValue);
                const newBoard = {
                    id: Date.now(),
                    name: boardData.name,
                    width: boardData.width,
                    height: boardData.height,
                    x: (effectiveBoardWidthCm / 2) - (boardData.width / 2), // Position in center
                    y: (effectiveBoardHeightCm / 2) - (boardData.height / 2), // Position in center
                    color: boardData.color || '#000000', // Use predefined color or default to black
                    isBoard: true,
                    currentRotationAngle: 0
                };
                elements.push(newBoard);
                drawElements();
                saveElements();
                predefinedBoardSelect.value = ""; // Reset dropdown to placeholder after selection
            });



            // Event listener for adding predefined pedal (now on change)
            predefinedPedalSelect.addEventListener('change', () => {
                const selectedOptionValue = predefinedPedalSelect.value;
                if (!selectedOptionValue) {
                    return; // Do nothing if the placeholder option is selected
                }
                const pedalData = JSON.parse(selectedOptionValue);
                console.log(pedalData);
                const newPedal = {
                    id: Date.now(),
                    name: pedalData.Name,
                    width: inchesToCm(pedalData.Width).toFixed(1),
                    height: inchesToCm(pedalData.Height).toFixed(1),
                    x: (effectiveBoardWidthCm / 2) - (inchesToCm(pedalData.Width).toFixed(1) / 2), // Position in center
                    y: (effectiveBoardHeightCm / 2) - (inchesToCm(pedalData.Height).toFixed(1) / 2), // Position in center
                    color: pedalData.color || '#3498db', // Use predefined color or default
                    isBoard: false,
                    currentRotationAngle: 0
                };
                elements.push(newPedal);
                drawElements();
                saveElements();
                predefinedPedalSelect.value = ""; // Reset dropdown to placeholder after selection
            });

            // Phase 4 - Event listeners for new inputs
            mainBoardWidthInput.addEventListener('input', () => {
                const newWidth = parseFloat(mainBoardWidthInput.value);
                if (!isNaN(newWidth) && newWidth > 0) {
                    effectiveBoardWidthCm = newWidth;
                    resizeCanvas(); // Recalculate scale and redraw
                    saveElements();
                }
            });

            mainBoardHeightInput.addEventListener('input', () => {
                const newHeight = parseFloat(mainBoardHeightInput.value);
                if (!isNaN(newHeight) && newHeight > 0) {
                    effectiveBoardHeightCm = newHeight;
                    resizeCanvas(); // Recalculate scale and redraw
                    saveElements();
                }
            });

            resetBoardViewBtn.addEventListener('click', () => {
                console.log("Redefinir Visão da Tela button clicked.");
                resizeCanvas(); // Force recalculation and redraw to fit
                saveElements();
            });


            clearBoardBtn.addEventListener('click', () => {
                elements = [];
                selectedElement = null; // Clear selection
                drawElements();
                saveElements(); // Save after clearing
                showCustomAlert('Todos os elementos foram limpos!');
            });

            shareBoardBtn.addEventListener('click', async () => {
                console.log("Share button clicked. Initiating save process...");
                const boardId = await savePedalboardForSharing();
                if (boardId) {
                    console.log("Board ID obtained:", boardId, "Attempting to show share modal.");
                    const shareUrl = `${window.location.origin}${window.location.pathname}?boardId=${boardId}`;
                    shareUrlInput.value = shareUrl;
                    console.log("shareUrlInput.value set to:", shareUrlInput.value); // New log
                    console.log("shareModal element before showing:", shareModal); // Debug log
                    shareModal.classList.remove('hidden');
                    console.log("Share modal should now be visible.");
                } else {
                    console.log("Failed to get board ID. Share modal will not be shown.");
                }
            });

            copyShareUrlBtn.addEventListener('click', () => {
                shareUrlInput.select();
                document.execCommand('copy');
                showCustomAlert('URL copiada para a área de transferência!');
                console.log("Share URL copied.");
            });

            closeShareModalBtn.addEventListener('click', () => {
                shareModal.classList.add('hidden');
                console.log("Share modal hidden.");
            });

            setupCanvasMouseEvents(); // Setup mouse events
            setupCanvasTouchEvents(); // Setup touch events

            toggleSidebarBtn.addEventListener('click', () => {
                sidebar.classList.toggle('-translate-x-full');
                resizeCanvas();
            });

            closeSidebarBtn.addEventListener('click', () => {
                sidebar.classList.add('-translate-x-full');
                resizeCanvas();
            });

            // Initial check for sidebar visibility on load for desktop
            if (window.innerWidth >= 1024) {
                sidebar.classList.remove('-translate-x-full');
            }
            resizeCanvas(); // Initial call to resize and draw elements (after loading settings)
        }); // End of DOMContentLoaded

        // Add event listener for window resize outside DOMContentLoaded as it's a global event
        window.addEventListener('resize', resizeCanvas);
        // Add keyboard event listener globally
        document.addEventListener('keydown', handleKeyDown);

    </script>
</body>
</html>
